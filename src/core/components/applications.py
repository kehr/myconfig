"""
Applications configuration backup/restore component
 - Scans installed GUI applications in /Applications and ~/Applications
 - Optionally exports known configuration directories for common developer apps
 - Generates Applications list and optional install command hints
"""

from __future__ import annotations
import os
import re
from typing import Dict, List, Tuple
from core.base import BackupComponent


class ApplicationsComponent(BackupComponent):
    """Handles scanning and exporting configurations for GUI applications"""

    def __init__(self, executor):
        super().__init__(executor)
        # Load from configuration only (no hard-coded defaults)
        cfg_map = getattr(self.config, "applications_known", {}) or {}
        self.known_app_config_map: Dict[str, List[str]] = {
            k: [os.path.expanduser(p) for p in v]
            for k, v in cfg_map.items()
        }

    def is_available(self) -> bool:
        return True

    def is_enabled(self) -> bool:
        return getattr(self.config, "enable_applications", True)

    def _list_installed_apps(self) -> List[str]:
        apps_dirs = ["/Applications", os.path.expanduser("~/Applications")]
        found: List[str] = []
        for base in apps_dirs:
            try:
                if not os.path.isdir(base):
                    continue
                for name in os.listdir(base):
                    if name.endswith(".app"):
                        found.append(name[:-4])
            except Exception:
                continue
        # De-duplicate and sort
        return sorted(list(dict.fromkeys(found)))

    def _slugify(self, name: str) -> str:
        return re.sub(r"[^a-z0-9]+", "-", name.lower()).strip("-")

    def _expand_globs(self, path: str) -> List[str]:
        # Support simple wildcard expansion for known JetBrains/Sublime patterns
        import glob
        return glob.glob(path)

    def export(self, output_dir: str) -> bool:
        apps = self._list_installed_apps()
        if not apps:
            self.logger.info("No Applications found to export")
            return True

        out_apps_dir = os.path.join(output_dir, "Applications")
        os.makedirs(out_apps_dir, exist_ok=True)

        # Save discovery list
        try:
            with open(os.path.join(out_apps_dir, "Applications_list.txt"), "w", encoding="utf-8") as f:
                for a in apps:
                    f.write(a + "\n")
        except Exception:
            pass

        exported_any = False
        # Export known app configs
        for app_key, paths in self.known_app_config_map.items():
            if not any(app_key.lower() in a.lower() for a in apps):
                continue
            include = True
            if self.executor.config.interactive:
                include = self.executor.confirm(f"Include configuration for '{app_key}'?")
            if not include:
                continue

            for p in paths:
                candidates = [p]
                if any(ch in p for ch in ["*", "?", "["]):
                    candidates = self._expand_globs(p)
                for src in candidates:
                    if not os.path.exists(src):
                        continue
                    slug = self._slugify(app_key)
                    dest_dir = os.path.join(out_apps_dir, slug)
                    os.makedirs(dest_dir, exist_ok=True)
                    # Use shell cp -a for preserving attrs
                    if os.path.isdir(src):
                        self.executor.run(f'cp -a "{src}" "{dest_dir}/"', check=False, description=f"Backup {app_key} dir")
                        exported_any = True
                    elif os.path.isfile(src):
                        self.executor.run(f'cp -a "{src}" "{dest_dir}/"', check=False, description=f"Backup {app_key} file")
                        exported_any = True

        # Generate install command hints (brew casks, mas)
        self._generate_install_hints(out_apps_dir)
        return exported_any

    def _generate_install_hints(self, out_apps_dir: str) -> None:
        lines: List[str] = ["#!/usr/bin/env bash", "set -e", "# Installation helper generated by MyConfig"]
        # Homebrew formulae and casks
        if self.executor.which("brew"):
            rc_f, out_f = self.executor.run_output("brew list --formula")
            rc_c, out_c = self.executor.run_output("brew list --cask")
            if rc_f == 0 and out_f.strip():
                lines.append("\n# Homebrew formulae")
                for n in out_f.strip().splitlines():
                    n = n.strip()
                    if n:
                        lines.append(f"brew install {n}")
            if rc_c == 0 and out_c.strip():
                lines.append("\n# Homebrew casks")
                for n in out_c.strip().splitlines():
                    n = n.strip()
                    if n:
                        lines.append(f"brew install --cask {n}")
        # Mac App Store apps
        if self.executor.which("mas"):
            rc_m, out_m = self.executor.run_output("mas list | awk '{print $1" "$2}'")
            if rc_m == 0 and out_m.strip():
                lines.append("\n# Mac App Store apps (requires login)")
                # mas list prints: "12345 App Name"
                rc_raw, out_raw = self.executor.run_output("mas list")
                if rc_raw == 0:
                    for line in out_raw.splitlines():
                        parts = line.split()
                        if parts and parts[0].isdigit():
                            lines.append(f"mas install {parts[0]}")
        # VS Code extensions
        if self.executor.which("code"):
            rc_v, out_v = self.executor.run_output("code --list-extensions")
            if rc_v == 0 and out_v.strip():
                lines.append("\n# VS Code extensions")
                for ext in out_v.splitlines():
                    ext = ext.strip()
                    if ext:
                        lines.append(f"code --install-extension {ext}")

        try:
            helper = os.path.join(out_apps_dir, "INSTALL_COMMANDS.sh")
            with open(helper, "w", encoding="utf-8") as f:
                f.write("\n".join(lines) + "\n")
        except Exception:
            pass

    def restore(self, backup_dir: str) -> bool:
        apps_dir = os.path.join(backup_dir, "Applications")
        if not os.path.isdir(apps_dir):
            return False
        restored = False
        # Iterate over exported app directories and restore with confirmation
        for entry in os.listdir(apps_dir):
            src_dir = os.path.join(apps_dir, entry)
            if not os.path.isdir(src_dir):
                continue
            # Best-effort mapping: ask user for destination
            if not self.executor.confirm(f"Restore configuration for '{entry}' from backup?"):
                continue
            # Heuristics: common destinations under Library or .config
            # Let user provide path interactively is out-of-scope; copy back under home keeping structure
            dest = os.path.expanduser("~")
            self.executor.run(f'cp -a "{src_dir}" "{dest}/"', check=False, description=f"Restore {entry}")
            restored = True
        return restored

    def preview_export(self, output_dir: str) -> List[str]:
        apps = self._list_installed_apps()
        if not apps:
            return ["✗ No Applications detected"]
        return [f"✓ Applications list ({len(apps)} apps)", "✓ Known app configurations (if present)"]

    def preview_restore(self, backup_dir: str) -> List[str]:
        apps_dir = os.path.join(backup_dir, "Applications")
        if not os.path.isdir(apps_dir):
            return ["✗ No Applications directory in backup"]
        count = len([d for d in os.listdir(apps_dir) if os.path.isdir(os.path.join(apps_dir, d))])
        return [f"✓ {count} application configuration sets available"]


